ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/plb/r2d4/data/1_testing_r2d4_2015_Mar_18_1353
p8
sS'runtimeInfo'
p9
NsS'name'
p10
Vtesting_r2d4
p11
sS'dataNames'
p12
(lp13
S'response.keys'
p14
aS'response.corr'
p15
aS'response.rt'
p16
aS'key_resp_3.keys'
p17
aS'key_resp_3.corr'
p18
aS'key_resp_3.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
S'date'
p23
V2015_Mar_18_1353
p24
sS'frameRate'
p25
cnumpy.core.multiarray
scalar
p26
(cnumpy
dtype
p27
(S'f8'
I0
I1
tRp28
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xb5[\xcef\x8a\xf5M@'
tRp29
sS'expName'
p30
g11
sS'session'
p31
V001
p32
sS'participant'
p33
V1
ssS'loopsUnfinished'
p34
(lp35
g1
(cpsychopy.data
TrialHandler
p36
g3
NtRp37
(dp38
S'origin'
p39
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p40
sS'thisTrial'
p41
NsS'_exp'
p42
I4590539152
sg10
S'blocks'
p43
sg6
S'r2d4_pilot.py'
p44
sS'thisRepN'
p45
I0
sg20
I01
sg21
g22
sS'data'
p46
g1
(cpsychopy.data
DataHandler
p47
c__builtin__
dict
p48
(dp49
S'ran'
p50
cnumpy.ma.core
_mareconstruct
p51
(cnumpy.ma.core
MaskedArray
p52
cnumpy
ndarray
p53
(I0
tp54
S'b'
tRp55
(I1
(I1
I2
tg27
(S'f4'
I0
I1
tRp56
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00'
NtbsS'order'
p57
g51
(g52
g53
g54
S'b'
tRp58
(I1
(I1
I2
tg56
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01'
NtbstRp59
(dp60
S'isNumeric'
p61
(dp62
g50
I01
sg57
I01
ssS'trials'
p63
g37
sS'dataTypes'
p64
(lp65
g50
ag57
asS'dataShape'
p66
(lp67
I1
aI2
asbsS'method'
p68
S'random'
p69
sS'sequenceIndices'
p70
cnumpy.core.multiarray
_reconstruct
p71
(g53
(I0
tS'b'
tRp72
(I1
(I1
I2
tg27
(S'i8'
I0
I1
tRp73
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p74
I00
sS'nReps'
p75
I2
sS'nRemaining'
p76
I1
sS'trialList'
p77
(lp78
NasS'seed'
p79
NsS'thisIndex'
p80
g26
(g73
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp81
sS'thisN'
p82
I0
sS'thisTrialN'
p83
I0
sS'nTotal'
p84
I2
sS'_warnUseOfNext'
p85
I01
sbag1
(g36
g3
NtRp86
(dp87
g39
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p88
sg41
g1
(cpsychopy.data
TrialType
p89
g48
(dp90
S'image_id'
p91
S'image_folder/stim_3.png'
p92
sS'cor_ans_img'
p93
g26
(g73
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp94
stRp95
sg42
I4590539152
sg10
S'remap'
p96
sg6
g44
sg45
I0
sg20
I01
sg21
g22
sg46
g1
(g47
g48
(dp97
g50
g51
(g52
g53
g54
S'b'
tRp98
(I1
(I4
I1
tg56
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg17
g51
(g52
g53
g54
S'b'
tRp99
(I1
(I4
I1
tg27
(S'O8'
I0
I1
tRp100
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\xd0_Q\x00\x01\x00\x00\x00\xd0\x8fX\x00\x01\x00\x00\x00\xa8u\x9f\x16\x01\x00\x00\x00\xd0u\x9f\x16\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg18
g51
(g52
g53
g54
S'b'
tRp101
(I1
(I4
I1
tg56
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x01\x01'
Ntbsg57
g51
(g52
g53
g54
S'b'
tRp102
(I1
(I4
I1
tg56
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00\x00\x00'
S'\x00\x00\x00\x01'
Ntbsg19
g51
(g52
g53
g54
S'b'
tRp103
(I1
(I4
I1
tg56
I00
S'\x80\x15x?\x00\xd8\x04?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x01\x01'
NtbstRp104
(dp105
g61
(dp106
g50
I01
sg17
I00
sg18
I01
sg57
I01
sg19
I01
ssg63
g86
sg64
(lp107
g50
ag57
ag17
ag18
ag19
asg66
(lp108
I4
aI1
asbsg68
S'sequential'
p109
sg70
g71
(g53
(I0
tS'b'
tRp110
(I1
(I4
I1
tg73
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg74
I00
sg75
I1
sg76
I1
sg77
(lp111
g1
(g89
g48
(dp112
g91
S'image_folder/stim_1.png'
p113
sg93
g26
(g73
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp114
stRp115
ag1
(g89
g48
(dp116
g91
S'image_folder/stim_2.png'
p117
sg93
g26
(g73
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp118
stRp119
ag95
ag1
(g89
g48
(dp120
g91
S'image_folder/stim_4.png'
p121
sg93
g26
(g73
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp122
stRp123
asg79
Nsg80
g26
(g73
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp124
sg82
I2
sg83
I2
sg84
I4
sg85
I01
sbasS'saveWideText'
p125
I01
sS'thisEntry'
p126
(dp127
sS'version'
p128
S''
sS'_paramNamesSoFar'
p129
(lp130
S'stimulus'
p131
aS'cor_ans'
p132
ag91
ag93
asS'entries'
p133
(lp134
(dp135
g31
g32
sg14
S'3'
sS'blocks.thisIndex'
p136
g81
sS'sequences.thisN'
p137
I0
sg25
g29
sS'sequences.thisTrialN'
p138
I0
sS'sequences.thisRepN'
p139
I0
sS'blocks.thisTrial'
p140
Nsg131
g26
(g73
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp141
sg15
I0
sg30
g11
sS'blocks.thisRepN'
p142
I0
sg23
g24
sg33
V1
sg132
g26
(g73
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp143
sS'sequences.thisIndex'
p144
g26
(g73
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp145
sg16
F1.3855659961700439
sS'blocks.thisN'
p146
I0
sS'blocks.thisTrialN'
p147
I0
sa(dp148
g31
g32
sg14
S'3'
sS'blocks.thisIndex'
p149
g81
sS'sequences.thisN'
p150
I1
sg25
g29
sS'sequences.thisTrialN'
p151
I1
sS'sequences.thisRepN'
p152
I0
sS'blocks.thisTrial'
p153
Nsg131
g26
(g73
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp154
sg15
I1
sg30
g11
sS'blocks.thisRepN'
p155
I0
sg23
g24
sg33
V1
sg132
g26
(g73
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp156
sS'sequences.thisIndex'
p157
g26
(g73
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg16
F0.80229020118713379
sS'blocks.thisN'
p159
I0
sS'blocks.thisTrialN'
p160
I0
sa(dp161
g31
g32
sg14
S'4'
sS'blocks.thisIndex'
p162
g81
sS'sequences.thisN'
p163
I2
sg25
g29
sS'sequences.thisTrialN'
p164
I2
sS'sequences.thisRepN'
p165
I0
sS'blocks.thisTrial'
p166
Nsg131
g26
(g73
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp167
sg15
I1
sg30
g11
sS'blocks.thisRepN'
p168
I0
sg23
g24
sg33
V1
sg132
g26
(g73
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp169
sS'sequences.thisIndex'
p170
g26
(g73
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp171
sg16
F0.7339789867401123
sS'blocks.thisN'
p172
I0
sS'blocks.thisTrialN'
p173
I0
sa(dp174
g31
g32
sg14
S'5'
sS'blocks.thisIndex'
p175
g81
sS'sequences.thisN'
p176
I3
sg25
g29
sS'sequences.thisTrialN'
p177
I3
sS'sequences.thisRepN'
p178
I0
sS'blocks.thisTrial'
p179
Nsg131
g26
(g73
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp180
sg15
I1
sg30
g11
sS'blocks.thisRepN'
p181
I0
sg23
g24
sg33
V1
sg132
g26
(g73
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp182
sS'sequences.thisIndex'
p183
g26
(g73
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp184
sg16
F0.63579702377319336
sS'blocks.thisN'
p185
I0
sS'blocks.thisTrialN'
p186
I0
sa(dp187
S'remap.thisRepN'
p188
I0
sS'remap.thisN'
p189
I0
sg30
g11
sg33
V1
sg93
g114
sS'remap.thisIndex'
p190
g26
(g73
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp191
sS'blocks.thisIndex'
p192
g81
sg25
g29
sS'remap.thisTrialN'
p193
I0
sS'blocks.thisTrial'
p194
Nsg91
g113
sg18
I1
sg31
g32
sS'blocks.thisRepN'
p195
I0
sg23
g24
sg17
S'2'
sg19
F0.96907806396484375
sS'blocks.thisN'
p196
I0
sS'blocks.thisTrialN'
p197
I0
sa(dp198
S'remap.thisRepN'
p199
I0
sS'remap.thisN'
p200
I1
sg30
g11
sg33
V1
sg93
g118
sS'remap.thisIndex'
p201
g26
(g73
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp202
sS'blocks.thisIndex'
p203
g81
sg25
g29
sS'remap.thisTrialN'
p204
I1
sS'blocks.thisTrial'
p205
Nsg91
g117
sg18
I1
sg31
g32
sS'blocks.thisRepN'
p206
I0
sg23
g24
sg17
S'3'
sg19
F0.5189208984375
sS'blocks.thisN'
p207
I0
sS'blocks.thisTrialN'
p208
I0
sasS'loops'
p209
(lp210
g37
ag1
(g36
g3
NtRp211
(dp212
g39
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p213
sg41
(lp214
sg42
I4590539152
sg10
S'sequences'
p215
sg6
g44
sg45
I1
sg20
I01
sg21
g22
sg46
g1
(g47
g48
(dp216
g50
g51
(g52
g53
g54
S'b'
tRp217
(I1
(I4
I1
tg56
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg14
g51
(g52
g53
g54
S'b'
tRp218
(I1
(I4
I1
tg100
I00
S'\xd0\x8fX\x00\x01\x00\x00\x00\xd0\x8fX\x00\x01\x00\x00\x00\x80\xa0Y\x00\x01\x00\x00\x00\x08_Q\x00\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg15
g51
(g52
g53
g54
S'b'
tRp219
(I1
(I4
I1
tg56
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg16
g51
(g52
g53
g54
S'b'
tRp220
(I1
(I4
I1
tg56
I00
S':Z\xb1?\xe4bM?\x0c\xe6;?\x98\xc3"?'
S'\x00\x00\x00\x00'
Ntbsg57
g51
(g52
g53
g54
S'b'
tRp221
(I1
(I4
I1
tg56
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp222
(dp223
g61
(dp224
g50
I01
sg16
I01
sg15
I01
sg14
I00
sg57
I01
ssg63
g211
sg64
(lp225
g50
ag57
ag14
ag15
ag16
asg66
(lp226
I4
aI1
asbsg68
g109
sg70
g71
(g53
(I0
tS'b'
tRp227
(I1
(I4
I1
tg73
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg74
I01
sg75
I1
sg76
I-1
sg77
(lp228
g1
(g89
g48
(dp229
g131
g141
sg132
g143
stRp230
ag1
(g89
g48
(dp231
g131
g154
sg132
g156
stRp232
ag1
(g89
g48
(dp233
g131
g167
sg132
g169
stRp234
ag1
(g89
g48
(dp235
g131
g180
sg132
g182
stRp236
asg79
Nsg80
g184
sg82
I4
sg83
I0
sg84
I4
sg85
I01
sbag86
asS'savePickle'
p237
I00
sb.