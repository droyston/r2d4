ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/plb/r2d4/data/1_testing_r2d4_2015_Mar_18_1425
p8
sS'runtimeInfo'
p9
NsS'name'
p10
Vtesting_r2d4
p11
sS'dataNames'
p12
(lp13
S'response.keys'
p14
aS'response.corr'
p15
aS'response.rt'
p16
aS'key_resp_3.keys'
p17
aS'key_resp_3.corr'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'date'
p22
V2015_Mar_18_1425
p23
sS'frameRate'
p24
cnumpy.core.multiarray
scalar
p25
(cnumpy
dtype
p26
(S'f8'
I0
I1
tRp27
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x98\xcb6q\x9f\xffM@'
tRp28
sS'expName'
p29
g11
sS'session'
p30
V001
p31
sS'participant'
p32
V1
ssS'loopsUnfinished'
p33
(lp34
g1
(cpsychopy.data
TrialHandler
p35
g3
NtRp36
(dp37
S'origin'
p38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p39
sS'thisTrial'
p40
NsS'_exp'
p41
I4607709584
sg10
S'blocks'
p42
sg6
S'r2d4_pilot.py'
p43
sS'thisRepN'
p44
I1
sg19
I01
sg20
g21
sS'data'
p45
g1
(cpsychopy.data
DataHandler
p46
c__builtin__
dict
p47
(dp48
S'ran'
p49
cnumpy.ma.core
_mareconstruct
p50
(cnumpy.ma.core
MaskedArray
p51
cnumpy
ndarray
p52
(I0
tp53
S'b'
tRp54
(I1
(I1
I2
tg26
(S'f4'
I0
I1
tRp55
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00'
NtbsS'order'
p56
g50
(g51
g52
g53
S'b'
tRp57
(I1
(I1
I2
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00'
NtbstRp58
(dp59
S'isNumeric'
p60
(dp61
g49
I01
sg56
I01
ssS'trials'
p62
g36
sS'dataTypes'
p63
(lp64
g49
ag56
asS'dataShape'
p65
(lp66
I1
aI2
asbsS'method'
p67
S'random'
p68
sS'sequenceIndices'
p69
cnumpy.core.multiarray
_reconstruct
p70
(g52
(I0
tS'b'
tRp71
(I1
(I1
I2
tg26
(S'i8'
I0
I1
tRp72
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p73
I00
sS'nReps'
p74
I2
sS'nRemaining'
p75
I0
sS'trialList'
p76
(lp77
NasS'seed'
p78
NsS'thisIndex'
p79
g25
(g72
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp80
sS'thisN'
p81
I1
sS'thisTrialN'
p82
I0
sS'nTotal'
p83
I2
sS'_warnUseOfNext'
p84
I01
sbag1
(g35
g3
NtRp85
(dp86
g38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p87
sg40
g1
(cpsychopy.data
TrialType
p88
g47
(dp89
S'stimulus'
p90
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp91
sS'cor_ans'
p92
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp93
stRp94
sg41
I4607709584
sg10
S'sequences'
p95
sg6
g43
sg44
I0
sg19
I01
sg20
g21
sg45
g1
(g46
g47
(dp96
g49
g50
(g51
g52
g53
S'b'
tRp97
(I1
(I4
I1
tg55
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg15
g50
(g51
g52
g53
S'b'
tRp98
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01'
Ntbsg14
g50
(g51
g52
g53
S'b'
tRp99
(I1
(I4
I1
tg26
(S'O8'
I0
I1
tRp100
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'@\xdc\x17\x00\x01\x00\x00\x00h\xb9\x16\x17\x01\x00\x00\x00\xb8\xb9\x16\x17\x01\x00\x00\x00\xe0\xb9\x16\x17\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg56
g50
(g51
g52
g53
S'b'
tRp101
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x01\x01'
NtbstRp102
(dp103
g60
(dp104
g49
I01
sg15
I01
sg14
I00
sg56
I01
ssg62
g85
sg63
(lp105
g49
ag56
ag14
ag15
asg65
(lp106
I4
aI1
asbsg67
S'sequential'
p107
sg69
g70
(g52
(I0
tS'b'
tRp108
(I1
(I4
I1
tg72
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg73
I00
sg74
I1
sg75
I2
sg76
(lp109
g1
(g88
g47
(dp110
g90
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp111
sg92
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp112
stRp113
ag94
ag1
(g88
g47
(dp114
g90
g25
(g72
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp115
sg92
g25
(g72
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp116
stRp117
ag1
(g88
g47
(dp118
g90
g25
(g72
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp119
sg92
g25
(g72
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp120
stRp121
asg78
Nsg79
g25
(g72
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp122
sg81
I1
sg82
I1
sg83
I4
sg84
I01
sbasS'saveWideText'
p123
I01
sS'thisEntry'
p124
(dp125
sS'version'
p126
S''
sS'_paramNamesSoFar'
p127
(lp128
S'stimulus'
p129
aS'cor_ans'
p130
aS'image_id'
p131
aS'cor_ans_img'
p132
asS'entries'
p133
(lp134
(dp135
g30
g31
sg14
S'3'
sS'blocks.thisIndex'
p136
g25
(g72
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp137
sS'sequences.thisN'
p138
I0
sg24
g28
sS'sequences.thisTrialN'
p139
I0
sS'sequences.thisRepN'
p140
I0
sS'blocks.thisTrial'
p141
Nsg129
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp142
sg15
I0
sg29
g11
sS'blocks.thisRepN'
p143
I0
sg22
g23
sg32
V1
sg130
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp144
sS'sequences.thisIndex'
p145
g25
(g72
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp146
sg16
F1.2856118679046631
sS'blocks.thisN'
p147
I0
sS'blocks.thisTrialN'
p148
I0
sa(dp149
g30
g31
sg14
S'4'
sS'blocks.thisIndex'
p150
g137
sS'sequences.thisN'
p151
I1
sg24
g28
sS'sequences.thisTrialN'
p152
I1
sS'sequences.thisRepN'
p153
I0
sS'blocks.thisTrial'
p154
Nsg129
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp155
sg15
I0
sg29
g11
sS'blocks.thisRepN'
p156
I0
sg22
g23
sg32
V1
sg130
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp157
sS'sequences.thisIndex'
p158
g25
(g72
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp159
sg16
F1.4026589393615723
sS'blocks.thisN'
p160
I0
sS'blocks.thisTrialN'
p161
I0
sa(dp162
g30
g31
sg14
S'5'
sS'blocks.thisIndex'
p163
g137
sS'sequences.thisN'
p164
I2
sg24
g28
sS'sequences.thisTrialN'
p165
I2
sS'sequences.thisRepN'
p166
I0
sS'blocks.thisTrial'
p167
Nsg129
g25
(g72
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp168
sg15
I0
sg29
g11
sS'blocks.thisRepN'
p169
I0
sg22
g23
sg32
V1
sg130
g25
(g72
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp170
sS'sequences.thisIndex'
p171
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp172
sg16
F1.4191310405731201
sS'blocks.thisN'
p173
I0
sS'blocks.thisTrialN'
p174
I0
sa(dp175
g30
g31
sg14
S'5'
sS'blocks.thisIndex'
p176
g137
sS'sequences.thisN'
p177
I3
sg24
g28
sS'sequences.thisTrialN'
p178
I3
sS'sequences.thisRepN'
p179
I0
sS'blocks.thisTrial'
p180
Nsg129
g25
(g72
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp181
sg15
I1
sg29
g11
sS'blocks.thisRepN'
p182
I0
sg22
g23
sg32
V1
sg130
g25
(g72
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp183
sS'sequences.thisIndex'
p184
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp185
sg16
F0.20225191116333008
sS'blocks.thisN'
p186
I0
sS'blocks.thisTrialN'
p187
I0
sa(dp188
S'remap.thisRepN'
p189
I0
sS'remap.thisN'
p190
I0
sg29
g11
sg32
V1
sg132
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp191
sS'remap.thisIndex'
p192
g25
(g72
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp193
sS'blocks.thisIndex'
p194
g137
sg24
g28
sS'blocks.thisTrial'
p195
Nsg131
S'image_folder/stim_1.png'
p196
sg18
I0
sg30
g31
sS'blocks.thisRepN'
p197
I0
sg22
g23
sg17
NsS'remap.thisTrialN'
p198
I0
sS'blocks.thisN'
p199
I0
sS'blocks.thisTrialN'
p200
I0
sa(dp201
S'remap.thisRepN'
p202
I0
sS'remap.thisN'
p203
I1
sg29
g11
sg32
V1
sg132
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp204
sS'remap.thisIndex'
p205
g25
(g72
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp206
sS'blocks.thisIndex'
p207
g137
sg24
g28
sS'blocks.thisTrial'
p208
Nsg131
S'image_folder/stim_2.png'
p209
sg18
I0
sg30
g31
sS'blocks.thisRepN'
p210
I0
sg22
g23
sg17
NsS'remap.thisTrialN'
p211
I1
sS'blocks.thisN'
p212
I0
sS'blocks.thisTrialN'
p213
I0
sa(dp214
S'remap.thisRepN'
p215
I0
sS'remap.thisN'
p216
I2
sg29
g11
sg32
V1
sg132
g25
(g72
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp217
sS'remap.thisIndex'
p218
g25
(g72
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp219
sS'blocks.thisIndex'
p220
g137
sg24
g28
sS'blocks.thisTrial'
p221
Nsg131
S'image_folder/stim_3.png'
p222
sg18
I0
sg30
g31
sS'blocks.thisRepN'
p223
I0
sg22
g23
sg17
NsS'remap.thisTrialN'
p224
I2
sS'blocks.thisN'
p225
I0
sS'blocks.thisTrialN'
p226
I0
sa(dp227
S'remap.thisRepN'
p228
I0
sS'remap.thisN'
p229
I3
sg29
g11
sg32
V1
sg132
g25
(g72
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp230
sS'remap.thisIndex'
p231
g25
(g72
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp232
sS'blocks.thisIndex'
p233
g137
sg24
g28
sS'blocks.thisTrial'
p234
Nsg131
S'image_folder/stim_4.png'
p235
sg18
I0
sg30
g31
sS'blocks.thisRepN'
p236
I0
sg22
g23
sg17
NsS'remap.thisTrialN'
p237
I3
sS'blocks.thisN'
p238
I0
sS'blocks.thisTrialN'
p239
I0
sa(dp240
g30
g31
sg32
V1
sS'blocks.thisIndex'
p241
g137
sg24
g28
sS'blocks.thisTrial'
p242
Nsg29
g11
sS'blocks.thisRepN'
p243
I0
sg22
g23
sS'blocks.thisN'
p244
I0
sS'blocks.thisTrialN'
p245
I0
sa(dp246
g30
g31
sg14
NsS'blocks.thisIndex'
p247
g80
sS'sequences.thisN'
p248
I0
sg24
g28
sS'sequences.thisTrialN'
p249
I0
sS'sequences.thisRepN'
p250
I0
sS'blocks.thisTrial'
p251
Nsg90
g111
sg15
I0
sg29
g11
sS'blocks.thisRepN'
p252
I1
sg22
g23
sg32
V1
sg92
g112
sS'sequences.thisIndex'
p253
g25
(g72
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp254
sS'blocks.thisN'
p255
I1
sS'blocks.thisTrialN'
p256
I0
sasS'loops'
p257
(lp258
g36
ag1
(g35
g3
NtRp259
(dp260
g38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p261
sg40
(lp262
sg41
I4607709584
sg10
g95
sg6
g43
sg44
I1
sg19
I01
sg20
g21
sg45
g1
(g46
g47
(dp263
g49
g50
(g51
g52
g53
S'b'
tRp264
(I1
(I4
I1
tg55
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg14
g50
(g51
g52
g53
S'b'
tRp265
(I1
(I4
I1
tg100
I00
S'\xd0\x8fH\x00\x01\x00\x00\x00\x80\xa0I\x00\x01\x00\x00\x00\x08_A\x00\x01\x00\x00\x00\x08_A\x00\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg15
g50
(g51
g52
g53
S'b'
tRp266
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg16
g50
(g51
g52
g53
S'b'
tRp267
(I1
(I4
I1
tg55
I00
S'\xee\x8e\xa4?T\x8a\xb3?\x16\xa6\xb5? \x1bO>'
S'\x00\x00\x00\x00'
Ntbsg56
g50
(g51
g52
g53
S'b'
tRp268
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp269
(dp270
g60
(dp271
g49
I01
sg16
I01
sg15
I01
sg14
I00
sg56
I01
ssg62
g259
sg63
(lp272
g49
ag56
ag14
ag15
ag16
asg65
(lp273
I4
aI1
asbsg67
g107
sg69
g70
(g52
(I0
tS'b'
tRp274
(I1
(I4
I1
tg72
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg73
I01
sg74
I1
sg75
I-1
sg76
(lp275
g1
(g88
g47
(dp276
g129
g142
sg130
g144
stRp277
ag1
(g88
g47
(dp278
g129
g155
sg130
g157
stRp279
ag1
(g88
g47
(dp280
g129
g168
sg130
g170
stRp281
ag1
(g88
g47
(dp282
g129
g181
sg130
g183
stRp283
asg78
Nsg79
g185
sg81
I4
sg82
I0
sg83
I4
sg84
I01
sbag1
(g35
g3
NtRp284
(dp285
g38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'testing_r2d4'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a\u000a#Add context\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='white', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text=u'Remember, choose the key corresponding to the number that you see displayed on the screen:\u005cn2 -- index\u005cn3 -- middle\u005cn4 -- ring\u005cn5 -- pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.3, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_2"\u000atrial_2Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instrText)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablocks = data.TrialHandler(nReps=2, method='random',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='blocks')\u000athisExp.addLoop(blocks)  # add the loop to the experiment\u000athisBlock = blocks.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock.rgb)\u000aif thisBlock != None:\u000a    for paramName in thisBlock.keys():\u000a        exec(paramName + '= thisBlock.' + paramName)\u000a\u000afor thisBlock in blocks:\u000a    currentLoop = blocks\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock.rgb)\u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    sequences = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'stimuli.csv'),\u000a        seed=None, name='sequences')\u000a    thisExp.addLoop(sequences)  # add the loop to the experiment\u000a    thisSequence = sequences.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisSequence.rgb)\u000a    if thisSequence != None:\u000a        for paramName in thisSequence.keys():\u000a            exec(paramName + '= thisSequence.' + paramName)\u000a\u000a    for thisSequence in sequences:\u000a        currentLoop = sequences\u000a        # abbreviate parameter names if possible (e.g. rgb = thisSequence.rgb)\u000a        if thisSequence != None:\u000a            for paramName in thisSequence.keys():\u000a                exec(paramName + '= thisSequence.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        Target.setText(stimulus)\u000a        response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        response.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(Target)\u000a        trialComponents.append(response)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *Target* updates\u000a            if t >= 0.5 and Target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Target.tStart = t  # underestimates by a little under one frame\u000a                Target.frameNStart = frameN  # exact frame index\u000a                Target.setAutoDraw(True)\u000a            if Target.status == STARTED and t >= (0.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                Target.setAutoDraw(False)\u000a\u000a            # *response* updates\u000a            if t >= 0.5 and response.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                response.tStart = t  # underestimates by a little under one frame\u000a                response.frameNStart = frameN  # exact frame index\u000a                response.status = STARTED\u000a                # keyboard checking is just starting\u000a                response.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if response.status == STARTED and t >= (0.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                response.status = STOPPED\u000a            if response.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    response.keys = theseKeys[-1]  # just the last key pressed\u000a                    response.rt = response.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                        response.corr = 1\u000a                    else:\u000a                        response.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(0.5)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if response.keys in ['', [], None]:  # No response was made\u000a           response.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a           else: response.corr = 0  # failed to respond (incorrectly)\u000a        # store data for sequences (TrialHandler)\u000a        sequences.addData('response.keys',response.keys)\u000a        sequences.addData('response.corr', response.corr)\u000a        if response.keys != None:  # we had a response\u000a            sequences.addData('response.rt', response.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'sequences'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    remap = data.TrialHandler(nReps=1, method='sequential',\u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(u'image_stim.csv'),\u000a        seed=None, name='remap')\u000a    thisExp.addLoop(remap)  # add the loop to the experiment\u000a    thisRemap = remap.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisRemap.rgb)\u000a    if thisRemap != None:\u000a        for paramName in thisRemap.keys():\u000a            exec(paramName + '= thisRemap.' + paramName)\u000a\u000a    for thisRemap in remap:\u000a        currentLoop = remap\u000a        # abbreviate parameter names if possible (e.g. rgb = thisRemap.rgb)\u000a        if thisRemap != None:\u000a            for paramName in thisRemap.keys():\u000a                exec(paramName + '= thisRemap.' + paramName)\u000a\u000a        #------Prepare to start Routine "trial_2"-------\u000a        t = 0\u000a        trial_2Clock.reset()  # clock\u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        image.setImage(image_id)\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial_2Components = []\u000a        trial_2Components.append(image)\u000a        trial_2Components.append(key_resp_3)\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "trial_2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *image* updates\u000a            if t >= .5 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            if image.status == STARTED and t >= (.5 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                image.setAutoDraw(False)\u000a\u000a            # *key_resp_3* updates\u000a            if t >= .5 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a            if key_resp_3.status == STARTED and t >= (.5 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['2', '3', '4', '5'])\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str(cor_ans_img)) or (key_resp_3.keys == cor_ans_img):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a\u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a\u000a        #-------Ending Routine "trial_2"-------\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str(cor_ans_img).lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for remap (TrialHandler)\u000a        remap.addData('key_resp_3.keys',key_resp_3.keys)\u000a        remap.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            remap.addData('key_resp_3.rt', key_resp_3.rt)\u000a        thisExp.nextEntry()\u000a\u000a    # completed 1 repeats of 'remap'\u000a\u000a    thisExp.nextEntry()\u000a\u000a# completed 2 repeats of 'blocks'\u000a\u000awin.close()\u000acore.quit()\u000a
p286
sg40
(lp287
sg41
I4607709584
sg10
S'remap'
p288
sg6
g43
sg44
I1
sg19
I01
sg20
g21
sg45
g1
(g46
g47
(dp289
g49
g50
(g51
g52
g53
S'b'
tRp290
(I1
(I4
I1
tg55
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg17
g50
(g51
g52
g53
S'b'
tRp291
(I1
(I4
I1
tg100
I00
S'@\xdc\x17\x00\x01\x00\x00\x00@\xdc\x17\x00\x01\x00\x00\x00@\xdc\x17\x00\x01\x00\x00\x00@\xdc\x17\x00\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg18
g50
(g51
g52
g53
S'b'
tRp292
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg56
g50
(g51
g52
g53
S'b'
tRp293
(I1
(I4
I1
tg55
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp294
(dp295
g60
(dp296
g49
I01
sg17
I00
sg18
I01
sg56
I01
ssg62
g284
sg63
(lp297
g49
ag56
ag17
ag18
asg65
(lp298
I4
aI1
asbsg67
g107
sg69
g70
(g52
(I0
tS'b'
tRp299
(I1
(I4
I1
tg72
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg73
I01
sg74
I1
sg75
I-1
sg76
(lp300
g1
(g88
g47
(dp301
g131
g196
sg132
g191
stRp302
ag1
(g88
g47
(dp303
g131
g209
sg132
g204
stRp304
ag1
(g88
g47
(dp305
g131
g222
sg132
g217
stRp306
ag1
(g88
g47
(dp307
g131
g235
sg132
g230
stRp308
asg78
Nsg79
g232
sg81
I4
sg82
I0
sg83
I4
sg84
I01
sbag85
asS'savePickle'
p309
I00
sb.