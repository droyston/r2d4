ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/plb/r2d4/data/1_test_2015_Mar_15_1751
p8
sS'runtimeInfo'
p9
NsS'name'
p10
Vtest
p11
sS'dataNames'
p12
(lp13
S'response.keys'
p14
aS'response.corr'
p15
aS'response.rt'
p16
asS'autoLog'
p17
I01
sS'extraInfo'
p18
(dp19
S'date'
p20
V2015_Mar_15_1751
p21
sS'frameRate'
p22
cnumpy.core.multiarray
scalar
p23
(cnumpy
dtype
p24
(S'f8'
I0
I1
tRp25
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xae\x9f\x10k\xba\x16N@'
tRp26
sS'expName'
p27
g11
sVsession
p28
V001
p29
sVparticipant
p30
V1
ssS'loopsUnfinished'
p31
(lp32
sS'saveWideText'
p33
I01
sS'thisEntry'
p34
(dp35
sS'version'
p36
S''
sS'_paramNamesSoFar'
p37
(lp38
S'stimulus'
p39
aS'cor_ans'
p40
asS'entries'
p41
(lp42
(dp43
g28
g29
sS'trials.thisIndex'
p44
g23
(g24
(S'i8'
I0
I1
tRp45
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp46
sg14
(lp47
S'2'
asg39
g23
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp48
sS'trials.thisRepN'
p49
I0
sg22
g26
sS'trials.thisN'
p50
I0
sg15
I0
sg27
g11
sS'trials.thisTrialN'
p51
I0
sg20
g21
sg30
V1
sg40
g23
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp52
sg16
(lp53
F0.26872110366821289
asa(dp54
g28
g29
sS'trials.thisIndex'
p55
g23
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp56
sg14
(lp57
S'4'
aS'4'
aS'4'
asg39
g23
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp58
sS'trials.thisRepN'
p59
I0
sg22
g26
sS'trials.thisN'
p60
I1
sg15
I0
sg27
g11
sS'trials.thisTrialN'
p61
I1
sg20
g21
sg30
V1
sg40
g23
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp62
sg16
(lp63
F0.36734890937805176
aF0.91903805732727051
aF1.2534759044647217
asa(dp64
g28
g29
sS'trials.thisIndex'
p65
g23
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp66
sg14
(lp67
S'4'
aS'5'
aS'5'
aS'5'
aS'5'
aS'5'
asg39
g23
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp68
sS'trials.thisRepN'
p69
I0
sg22
g26
sS'trials.thisN'
p70
I2
sg15
I0
sg27
g11
sS'trials.thisTrialN'
p71
I2
sg20
g21
sg30
V1
sg40
g23
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp72
sg16
(lp73
F0.0189361572265625
aF0.30247712135314941
aF0.53507208824157715
aF0.80255007743835449
aF1.0694541931152344
aF1.3192470073699951
asa(dp74
g28
g29
sS'trials.thisIndex'
p75
g23
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp76
sg14
(lp77
S'5'
aS'5'
aS'5'
asg39
g23
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp78
sS'trials.thisRepN'
p79
I0
sg22
g26
sS'trials.thisN'
p80
I3
sg15
I0
sg27
g11
sS'trials.thisTrialN'
p81
I3
sg20
g21
sg30
V1
sg40
g23
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp82
sg16
(lp83
F0.20142483711242676
aF0.43528294563293457
aF0.63531088829040527
asasS'loops'
p84
(lp85
g1
(cpsychopy.data
TrialHandler
p86
g3
NtRp87
(dp88
S'origin'
p89
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui, hardware\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'test'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[800, 400], fullscr=False, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor=u'testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000acontext = visual.Rect(win, width=1, height=1, autoDraw = True, lineColor='black', lineWidth = 6)\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000a\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000ainstructions = visual.TextStim(win=win, ori=0, name='instructions',\u000a    text=u'When the number appears on the screen tap your tap the corresponding key with that finger. \u005cn2 = pointer\u005cn3 = middle\u005cn4 = ring\u005cn5 = pinky',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000aTarget = visual.TextStim(win=win, ori=0, name='Target',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock\u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(instructions)\u000aInstructionsComponents.append(key_resp_2)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a\u000a    # *instructions* updates\u000a    if t >= 0.0 and instructions.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructions.tStart = t  # underestimates by a little under one frame\u000a        instructions.frameNStart = frameN  # exact frame index\u000a        instructions.setAutoDraw(True)\u000a\u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a\u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a\u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a\u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a\u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=1, method='sequential',\u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'stimuli.csv'),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock\u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    Target.setText(stimulus)\u000a    response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    response.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(ISI)\u000a    trialComponents.append(Target)\u000a    trialComponents.append(response)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *Target* updates\u000a        if t >= 1 and Target.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Target.tStart = t  # underestimates by a little under one frame\u000a            Target.frameNStart = frameN  # exact frame index\u000a            Target.setAutoDraw(True)\u000a        if Target.status == STARTED and t >= (1 + (.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            Target.setAutoDraw(False)\u000a\u000a        # *response* updates\u000a        if t >= 1 and response.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            response.tStart = t  # underestimates by a little under one frame\u000a            response.frameNStart = frameN  # exact frame index\u000a            response.status = STARTED\u000a            # keyboard checking is just starting\u000a            response.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if response.status == STARTED and t >= (1 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            response.status = STOPPED\u000a        if response.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5'])\u000a\u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                response.keys.extend(theseKeys)  # storing all keys\u000a                response.rt.append(response.clock.getTime())\u000a                # was this 'correct'?\u000a                if (response.keys == str(cor_ans)) or (response.keys == cor_ans):\u000a                    response.corr = 1\u000a                else:\u000a                    response.corr = 0\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(0.5)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a\u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if response.keys in ['', [], None]:  # No response was made\u000a       response.keys=None\u000a       # was no response the correct answer?!\u000a       if str(cor_ans).lower() == 'none': response.corr = 1  # correct non-response\u000a       else: response.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('response.keys',response.keys)\u000a    trials.addData('response.corr', response.corr)\u000a    if response.keys != None:  # we had a response\u000a        trials.addData('response.rt', response.rt)\u000a    thisExp.nextEntry()\u000a\u000a# completed 5 repeats of 'trials'\u000a\u000awin.close()\u000acore.quit()\u000a
p90
sS'thisTrial'
p91
(lp92
sS'_exp'
p93
I4570878288
sg10
S'trials'
p94
sg6
S'r2d4_pilot.py'
p95
sS'thisRepN'
p96
I1
sg17
I01
sg18
g19
sS'data'
p97
g1
(cpsychopy.data
DataHandler
p98
c__builtin__
dict
p99
(dp100
S'ran'
p101
cnumpy.ma.core
_mareconstruct
p102
(cnumpy.ma.core
MaskedArray
p103
cnumpy
ndarray
p104
(I0
tp105
S'b'
tRp106
(I1
(I4
I1
tg24
(S'f4'
I0
I1
tRp107
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg14
g102
(g103
g104
g105
S'b'
tRp108
(I1
(I4
I1
tg24
(S'O8'
I0
I1
tRp109
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'(J\xcb\x15\x01\x00\x00\x00\xd8\xc2\xc2\x15\x01\x00\x00\x00\xe0\x10z\x14\x01\x00\x00\x00\xe0@\xc3\x15\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg15
g102
(g103
g104
g105
S'b'
tRp110
(I1
(I4
I1
tg107
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg16
g102
(g103
g104
g105
S'b'
tRp111
(I1
(I4
I1
tg109
I00
S'\xb8J\xcb\x15\x01\x00\x00\x00\xb8\xc1\xc2\x15\x01\x00\x00\x00\x00B\xcb\x15\x01\x00\x00\x008\xcf\xc2\x15\x01\x00\x00\x00'
S'\x00\x00\x00\x00'
NtbsS'order'
p112
g102
(g103
g104
g105
S'b'
tRp113
(I1
(I4
I1
tg107
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp114
(dp115
S'isNumeric'
p116
(dp117
g101
I01
sg16
I00
sg15
I01
sg14
I00
sg112
I01
ssg94
g87
sS'dataTypes'
p118
(lp119
g101
ag112
ag14
ag15
ag16
asS'dataShape'
p120
(lp121
I4
aI1
asbsS'method'
p122
S'sequential'
p123
sS'sequenceIndices'
p124
cnumpy.core.multiarray
_reconstruct
p125
(g104
(I0
tS'b'
tRp126
(I1
(I4
I1
tg45
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p127
I01
sS'nReps'
p128
I1
sS'nRemaining'
p129
I-1
sS'trialList'
p130
(lp131
g1
(cpsychopy.data
TrialType
p132
g99
(dp133
g39
g48
sg40
g52
stRp134
ag1
(g132
g99
(dp135
g39
g58
sg40
g62
stRp136
ag1
(g132
g99
(dp137
g39
g68
sg40
g72
stRp138
ag1
(g132
g99
(dp139
g39
g78
sg40
g82
stRp140
asS'seed'
p141
NsS'thisIndex'
p142
g76
sS'thisN'
p143
I4
sS'thisTrialN'
p144
I0
sS'nTotal'
p145
I4
sS'_warnUseOfNext'
p146
I01
sbasS'savePickle'
p147
I00
sb.